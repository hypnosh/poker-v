<script>

const BUYINAMOUNT = 1000; //userinput
const BIGBLIND = (BUYINAMOUNT*2)/100; //userinput as an even number
const SMALLBLIND = BIGBLIND/2;
const MAXPLAYERS = 6;
var allInPot2;
var allInPot3;
var allInPot4;
var allInPot5;

//let potBalance = 0;  object being created housing all possible pots 1-5
const pots = [{potID: 1, potSize: 0, allInSize: null, potPlayers: [1,2,3,4,5,6]}, {potID: 2, potSize: 0, allInSize: allInPot2, potPlayers: []}, {potID: 3, potSize: 0, allInSize: allInPot3, potPlayers: []}, {potID: 4, potSize: 0, allInSize: allInPot4, potPlayers: []}, {potID: 5, potSize: 0, allInSize: allInPot5, potPlayers: []}]

//create an object array from user inputs (via database)
const playersBalStatus = [{key: 1, name: "Amit", stack: BUYINAMOUNT, status: "playing", sequence: 6, currentStBet: 0, totalHandBet: 0}, {key: 2, name: "Pratik", stack: BUYINAMOUNT, status: "playing", sequence: 1, currentStBet: 0, totalHandBet: 0}, {key: 3, name: "Saumitra", stack: BUYINAMOUNT, status: "playing", sequence: 2, currentStBet: 0, totalHandBet: 0}, {key: 4, name: "Premc", stack: BUYINAMOUNT, status: "playing", sequence: 3, currentStBet: 0, totalHandBet: 0}, {key: 5, name: "Manish", stack: BUYINAMOUNT, status: "folded", sequence: 4, currentStBet: 0, totalHandBet: 0}, {key: 6, name: "Rohan", stack: BUYINAMOUNT, status: "all-in", sequence: 5, currentStBet: 0, totalHandBet: 0}];

//excluding inactive players so can use the new array for streetBet function
const activePlayers = playersBalStatus.filter(player => player.status === "playing");

//sequencing activePlayers in order of betting turns
const sequencedActivePlayers = activePlayers.sort(function(a,b){return a.sequence - b.sequence});
const seqPlayerIds = sequencedActivePlayers.map(player => player.key);

const seqActivePlayerBal = sequencedActivePlayers.map(player => player.stack);

const bettingStreets = ["preflop", "flop", "turn", "river"];

function streetBetting() {
  var b = 0; //b stands for bet amount
  var streetBet = [];
  for (i = 0; i < activePlayers.length; i++) {
    let b = parseInt(prompt("Bet amount is "));//UI TO ENSURE THAT BET AMOUNT >= 0 AND <= STACK OF THE PLAYER
    pots[0].potSize += b;
    //potBalance = potBalance + b;
    let objInd = sequencedActivePlayers.findIndex((obj => obj.key === seqPlayerIds[i]));
    sequencedActivePlayers[objInd].stack -= b;
    //TO FACTOR IN WHAT TO DO IF A PLAYER FOLDS OR GOES ALL-IN. HOW TO REMOVE FOLDED PLAYER FROM THE LOOP FOR FURTHER BETS
    streetBet.push(b);
// TO REMOVE THE FOLDED PLAYER FROM THIS OBJECT STREETBET AT THIS STAGE OR SOMEHOW ENSURE THAT both the player and its bet GETS COUNTED AS NULL - SO THERE IS NO PROMPT FOR THIS PLAYER FOR ANY more BET
//How to filter without creating a new array
  }
  while (!(streetBet.every((val, i, arr) => val === arr[0]))) {
    for (i=0; i<activePlayers.length; i++) {
      if(!(streetBet.every((val, i, arr) => val === arr[0]))) {
        let b2 = parseInt(prompt("Bet amount is "));
        //TO FACTOR IN - if a player folds then the object array and the array, both get updated
        pots[0].potSize += b2;
        streetBet[i] += b2;
        let objInd2 = sequencedActivePlayers.findIndex((obj => obj.key === seqPlayerIds[i]));
        sequencedActivePlayers[objInd2].stack -= b2;
      }
    }
  }
  console.log(streetBet, pots);
}

var allinPlayerStBetAmount = parseInt(prompt("All-in Bet amount is "));//to pick up from user input from the event of choosing all-in for a player
streetBetting()

//given the allin bet amount and player who went allin, create a sidepot array
let j = 0;
function createSidePot(allinPlayerStBetAmount, allinPlayerID){
//even in a case where more than one player with same stack size goes allin in one street, the first player's allin creates this sidepot so the argument is first player.

  const playersForSidePot = playersBalStatus.filter(player => player.status === "playing" && player.stack > 0 && player.key != allinPlayerID);
  //consider adding && player.action != allIn as a condition
  if(playersForSidePot.length < 2) return console.log("At least two players needed for side pots");
  //TO ENSURE that when only two players are left, and one goes allin, the second player cant bet more than the allin amount
    else {
      j = j + 1
      //const sidePot1 = {sidePotID: j, sidePotSize: 0, allInSize: allinAmount, players: []};
      const sidePotPlayerIds = playersForSidePot.map(player => player.key);
      pots[j].potPlayers = sidePotPlayerIds;
      pots[j].allInSize = allinPlayerStBetAmount;
      if (allinPlayerStBetAmount < players[thisPlayerIndex-1].bet){ //Forced allin, i.e. allinamount is lower than last bet of the street. Bets so far in the street need to be split so that part remains in this pot and part shifts to new pot
        const streetBetToRemainInCurrentPot = thisStreet.forEach(function(x){ //const thisStreet = betObject[street] already defined in index.js
          return Math.max(x - allinStBetAmount, 0);
        }, 0);
        let totalStreetBetToRemainInCurrentPot = streetBetToRemainInCurrentPot.reduce(function(a,b){
          return a + b;
        }, 0);
        let totalStreetBet = thisStreet.reduce(function(a,b){
          return a+b;
        }, 0);
        let streetBetToShiftToNewPot = totalStreetBet - totalStreetBetToRemainInCurrentPot;
        pots[j].potSize = streetBetToShiftToNewPot;
        pots[j-1].potSize = pots[j-1].potSize - streetBetToShiftToNewPot;
      //db.collection("bets").doc(tableID).get().then(snapshot => {

      }
    }
  }

function sidePotBet(){
  let bet = parseInt(prompt("Bet amount is "));//this is the composite bet (main + side pot) of the player next to allinplayer
  const oldBet = thisStreet[playerID];//as defined in index.js
  const newBet = oldBet + bet;//as defined in index.js
  if (bet = playerStack){ //playerStack = players[thisPlayerIndex].stack already defined in index.js
    createSidePot(newBet, players[thisPlayerIndex].idx)}
    else if (newBet >= allinPlayerStBetAmount){
      pots[j-1].potSize += allinPlayerStBetAmount;
      pots[j].potSize = pots[j].potSize + newBet - allinPlayerStBetAmount;
    }
      else
        return "error: player can't bet lower than previous player bet in the street"

        //situation where subsequent player with a stack lower than allinAmount goes allin
}

createSidePot(800, 1);
sidePotBet();
console.log(pots);


</script>
